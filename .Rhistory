req(raw_data(), input$crd_traits, input$crd_n_factors)
df <- raw_data(); nfac <- as.numeric(input$crd_n_factors)
factor_names <- paste0("crd_factor", 1:nfac)
factor_cols <- sapply(factor_names, function(x) input[[x]])
# --- Original validation logic ---
if (any(is.null(factor_cols) | factor_cols == "")) {
showNotification("Please select all factors.", type = "error"); return(NULL)
}
if (any(!factor_cols %in% names(df))) {
showNotification("Selected factors do not match data columns.", type = "error"); return(NULL)
}
for (fac in factor_cols) df[[fac]] <- as.factor(df[[fac]])
for (trait in input$crd_traits) {
local({
trait_local <- trait; trait_id <- make.names(trait_local)
summary_tbl <- df %>%
group_by(across(all_of(factor_cols))) %>%
summarise(
mean = round(mean(.data[[trait_local]], na.rm = TRUE), 2),
SE = round(sd(.data[[trait_local]], na.rm = TRUE)/sqrt(n()), 2),
N = n(),
.groups = "drop"
)
# Assign the result directly to a named slot (e.g., crd_results$summary_Trait1)
crd_results[[paste0("summary_", trait_id)]] <- summary_tbl
# Render the output immediately
output[[paste0("crd_sum_", trait_id)]] <- DT::renderDataTable({
req(crd_results[[paste0("summary_", trait_id)]])
})
})
}
showNotification("Descriptive summary complete.", type = "message")
})
# --- Block C5: ANOVA + Post-Hoc (Corrected for reactiveValues) ---
observeEvent(input$run_crd_anova, {
req(raw_data(), input$crd_traits, input$crd_n_factors > 0)
waiter_show(html = tagList(spin_fading_circles(), h4("Running ANOVA and Post-Hoc...")))
df <- raw_data(); nfac <- as.numeric(input$crd_n_factors)
factor_names <- paste0("crd_factor", 1:nfac)
factor_cols <- na.omit(unname(sapply(factor_names, function(x) input[[x]])))
# --- Original validation logic ---
if (any(duplicated(factor_cols))) {
showNotification("Please select unique factors for each Factor slot!", type = "error"); waiter_hide(); return(NULL)
}
if (length(factor_cols) == 0) {
showNotification("Please select at least one valid factor.", type = "error"); waiter_hide(); return(NULL)
}
if (any(!factor_cols %in% names(df))) {
showNotification("Selected factors do not match data columns.", type = "error"); waiter_hide(); return(NULL)
}
for (fac in factor_cols) df[[fac]] <- as.factor(df[[fac]])
single_level_factors <- factor_cols[sapply(factor_cols, function(fac) length(unique(df[[fac]])) < 2)]
if (length(single_level_factors) > 0) {
msg <- paste("Some selected factors have only one level and will be ignored in ANOVA:", paste(single_level_factors, collapse = ", "))
showNotification(msg, type = "error"); waiter_hide(); return(NULL)
}
for (trait in input$crd_traits) {
local({
trait_local <- trait; trait_id <- make.names(trait_local)
# --- Original analysis variables and logic ---
anova_str <- ""; dmrt_str <- ""; anova_df <- data.frame(); missing <- data.frame()
if (!is.numeric(df[[trait_local]])) {
anova_str <- paste("Trait", trait_local, "is not numeric. Cannot run ANOVA.")
anova_df <- data.frame(Message = anova_str)
} else {
factors_bt <- sapply(factor_cols, function(x) if (grepl("[^A-Za-z0-9_.]", x)) paste0("`", x, "`") else x)
formula_str <- if (length(factors_bt) == 1) { paste(trait_local, "~", factors_bt[1]) } else { paste(trait_local, "~", paste(factors_bt, collapse = " * ")) }
fit <- tryCatch(aov(as.formula(formula_str), data = df), error = function(e) NULL)
if (!is.null(fit)) {
anova_df <- broom::tidy(fit)
anova_str <- "Shapiro-Wilk Test for Normality of Residuals:\n"
res <- tryCatch(residuals(fit), error = function(e) NULL)
if (!is.null(res) && length(res) > 3) {
shapiro <- tryCatch(shapiro.test(res), error = function(e) NULL)
if (!is.null(shapiro)) anova_str <- paste0(anova_str, paste(capture.output(shapiro), collapse = "\n"), "\n")
}
if (requireNamespace("agricolae", quietly = TRUE)) {
for (ff in factors_bt) {
dmrt <- tryCatch(agricolae::duncan.test(fit, ff, group=TRUE), error = function(e) NULL)
if (!is.null(dmrt)) dmrt_str <- paste0(dmrt_str, "\nDMRT for ", ff, ":\n", paste(capture.output(dmrt$groups), collapse = "\n"), "\n")
}
if (length(factors_bt) > 1) {
all_interactions <- unlist(lapply(2:length(factors_bt), function(m) combn(factors_bt, m, simplify = FALSE)), recursive = FALSE)
for (inter in all_interactions) {
term <- paste(inter, collapse=":")
dmrt <- tryCatch(agricolae::duncan.test(fit, term, group=TRUE), error = function(e) NULL)
if (!is.null(dmrt)) dmrt_str <- paste0(dmrt_str, "\nDMRT for interaction ", term, ":\n", paste(capture.output(dmrt$groups), collapse = "\n"), "\n")
}
}
} else { dmrt_str <- "\nagricolae package not available. DMRT not run.\n" }
} else { anova_str <- "ANOVA failed."; anova_df <- data.frame(Message = anova_str) }
}
full_grid <- expand.grid(lapply(df[factor_cols], function(x) levels(x))); actual <- df[, factor_cols, drop = FALSE] %>% distinct()
missing <- dplyr::anti_join(full_grid, actual, by = factor_cols)
# Assign each result directly to its own slot
crd_results[[paste0("anova_table_", trait_id)]] <- anova_df
crd_results[[paste0("dmrt_text_", trait_id)]] <- dmrt_str
crd_results[[paste0("report_", trait_id)]] <- paste(anova_str, "\n", dmrt_str)
crd_results[[paste0("missing_combinations_", trait_id)]] <- missing
# --- UI rendering logic ---
output[[paste0("crd_anova_", trait_id)]] <- DT::renderDataTable({ req(crd_results[[paste0("anova_table_", trait_id)]]) })
output[[paste0("crd_dmrt_", trait_id)]] <- renderPrint({ cat(crd_results[[paste0("dmrt_text_", trait_id)]]) })
output[[paste0("crd_missing_", trait_id)]] <- DT::renderDataTable({ req(crd_results[[paste0("missing_combinations_", trait_id)]]) })
})
}
waiter_hide()
showNotification("ANOVA and Post-Hoc analysis complete.", type = "message")
})
# -------- Block C6: CRD Interaction Plots (DEFINITIVE FIX for reactiveValues) --------
observeEvent(input$run_crd_interact, {
req(raw_data(), input$crd_traits, input$crd_n_factors > 0)
df <- raw_data(); nfac <- as.numeric(input$crd_n_factors)
factor_names <- paste0("crd_factor", 1:nfac)
factor_cols <- sapply(factor_names, function(x) input[[x]])
# --- Original validation logic ---
if (any(is.null(factor_cols) | factor_cols == "")) {
showNotification("Please select all factors.", type = "error"); return(NULL)
}
if (any(!factor_cols %in% names(df))) {
showNotification("Selected factors do not match data columns.", type = "error"); return(NULL)
}
for (fac in factor_cols) df[[fac]] <- as.factor(df[[fac]])
for (trait in input$crd_traits) {
local({
trait_local <- trait; trait_id <- make.names(trait_local)
plot_list <- list()
# --- UI registration using ns() (Original Logic) ---
output[[paste0("crd_interaction_panel_", trait_id)]] <- renderUI({
ui_list <- list()
if (nfac == 3) {
ui_list <- list(
tags$h4("Three-way Interaction"), plotOutput(ns(paste0("crd_interact_3way_", trait_id))),
tags$h4("Two-way Interactions"), plotOutput(ns(paste0("crd_interact_2way_", trait_id, "_1"))),
plotOutput(ns(paste0("crd_interact_2way_", trait_id, "_2"))), plotOutput(ns(paste0("crd_interact_2way_", trait_id, "_3")))
)
} else if (nfac == 2) {
ui_list <- list(tags$h4("Two-way Interaction"), plotOutput(ns(paste0("crd_interact_2way_", trait_id, "_1"))))
} else if (nfac == 1) {
ui_list <- list(plotOutput(ns(paste0("crd_interact_single_", trait_id))))
}
do.call(tagList, ui_list)
})
# --- Original plot building logic ---
if (nfac == 3) {
fac1 <- factor_cols[1]; fac2 <- factor_cols[2]; fac3 <- factor_cols[3]
df_summary_3way <- df %>% group_by(.data[[fac1]], .data[[fac2]], .data[[fac3]]) %>% summarise(mean_value = mean(.data[[trait_local]], na.rm=TRUE), .groups='drop')
p3way <- ggplot(df_summary_3way, aes(x=.data[[fac1]], y=mean_value, color=.data[[fac3]], group=.data[[fac3]])) + geom_line() + geom_point() + facet_wrap(as.formula(paste("~", fac2))) + labs(title=paste("3-way Interaction:", trait_local), x=fac1, y=paste("Mean", trait_local), color=fac3) + theme_bw() + theme(axis.text.x = element_text(angle=45, hjust=1))
plot_list[["3way"]] <- p3way
output[[paste0("crd_interact_3way_", trait_id)]] <- renderPlot({ print(p3way) })
all_pairs <- list(c(fac1, fac2), c(fac1, fac3), c(fac2, fac3))
for (i in seq_along(all_pairs)) {
xfac <- all_pairs[[i]][1]; linefac <- all_pairs[[i]][2]
df_summary_2way <- df %>% group_by(.data[[xfac]], .data[[linefac]]) %>% summarise(mean_value = mean(.data[[trait_local]], na.rm=TRUE), .groups='drop')
p2way <- ggplot(df_summary_2way, aes(x=.data[[xfac]], y=mean_value, color=.data[[linefac]], group=.data[[linefac]])) + geom_line() + geom_point() + labs(title=paste("2-way Interaction:", xfac, "x", linefac), x=xfac, y=paste("Mean", trait_local), color=linefac) + theme_bw() + theme(axis.text.x = element_text(angle=45, hjust=1))
plot_list[[paste0("2way_", i)]] <- p2way
output[[paste0("crd_interact_2way_", trait_id, "_", i)]] <- renderPlot({ print(p2way) })
}
} else if (nfac == 2) {
xfac <- factor_cols[1]; linefac <- factor_cols[2]
df_summary_2way <- df %>% group_by(.data[[xfac]], .data[[linefac]]) %>% summarise(mean_value = mean(.data[[trait_local]], na.rm=TRUE), .groups='drop')
p2way <- ggplot(df_summary_2way, aes(x=.data[[xfac]], y=mean_value, color=.data[[linefac]], group=.data[[linefac]])) + geom_line() + geom_point() + labs(title=paste("2-way Interaction:", trait_local), x=xfac, y=paste("Mean", trait_local), color=linefac) + theme_bw() + theme(axis.text.x = element_text(angle=45, hjust=1))
plot_list[["2way_1"]] <- p2way
output[[paste0("crd_interact_2way_", trait_id, "_1")]] <- renderPlot({ print(p2way) })
} else if (nfac == 1) {
fac <- factor_cols[1]
pbox <- ggplot(df, aes(x=.data[[fac]], y=.data[[trait_local]], fill=.data[[fac]])) + geom_boxplot() + labs(title=paste("Boxplot:", trait_local, "by", fac), x=fac, y=trait_local) + theme_bw() + theme(axis.text.x = element_text(angle=45, hjust=1), legend.position="none")
plot_list[["boxplot"]] <- pbox
output[[paste0("crd_interact_single_", trait_id)]] <- renderPlot({ print(pbox) })
}
# --- THE FIX: Directly assign the list of plots to its reactiveValues slot ---
crd_results[[paste0("plots_", trait_id)]] <- plot_list
})
}
showNotification("Interaction plots generated for all selected traits.", type = "message")
})
# --- Block E9: Update Analysis 2 Trait Selectors ---
observe({
mod_res <- model_results()
if (is.null(mod_res) || length(mod_res) == 0) return(NULL)
valid_fixed_results <- purrr::keep(mod_res, ~!is.null(.x$Fixed$blue_table) && is.data.frame(.x$Fixed$blue_table))
if(length(valid_fixed_results) == 0) return(NULL)
traits_with_blues <- names(purrr::keep(valid_fixed_results, ~"BLUE_Combined" %in% names(.x$Fixed$blue_table)))
traits_with_locwise_blues <- names(purrr::keep(valid_fixed_results, ~ncol(.x$Fixed$blue_table) > 3))
updateSelectInput(session, "gge_trait", choices = traits_with_locwise_blues, selected = if (length(traits_with_locwise_blues) > 0) traits_with_locwise_blues[[1]] else NULL)
updateCheckboxGroupInput(session, "multi_traits", choices = traits_with_blues, selected = traits_with_blues)
})
# --- Block E12: Analysis 2 - GGE Biplot ---
observeEvent(input$run_gge, {
req(input$gge_trait, model_results())
trait_data <- model_results()[[input$gge_trait]]$Fixed
req(trait_data, trait_data$blue_table, is.data.frame(trait_data$blue_table))
df_blue <- trait_data$blue_table
# This input$entry will come from the ns("entry") in the dynamic sidebar
entry_col_name <- make.names(input$entry)
df_gge <- df_blue %>%
dplyr::select(gen = all_of(entry_col_name), starts_with("BLUE_")) %>%
dplyr::select(-contains("BLUE_Combined"), -contains("SE_Combined")) %>%
tidyr::pivot_longer(cols = -gen, names_to = "env", values_to = "resp", names_prefix = "BLUE_")
tryCatch({
gge_model <- metan::gge(df_gge, env = env, gen = gen, resp = resp, scaling = 1)
gge_results(gge_model)
output$gge_plot_type1 <- renderPlot({ plot(gge_model, type = 3) })
output$gge_plot_type2 <- renderPlot({ plot(gge_model, type = 2) })
output$gge_plot_type3 <- renderPlot({ plot(gge_model, type = 4) })
output$gge_status <- renderUI({ span(style = "color: green; font-weight: bold;", icon("check"), " GGE Biplot Completed (OK)") })
updateTabsetPanel(session, "analysis2_tabs", selected = " GGE Biplot")
}, error = function(e) { showModal(modalDialog(title = "GGE Error", paste("Error in GGE analysis:", e$message), easyClose = TRUE)) })
})
# --- Block E13: Analysis 2 - PCA ---
observeEvent(input$run_pca, {
req(model_results(), input$multi_traits)
entry_col_name <- make.names(input$entry)
trait_df_list <- purrr::map(input$multi_traits, function(trait) {
res <- model_results()[[trait]]$Fixed
if (!is.null(res) && !is.null(res$blue_table) && "BLUE_Combined" %in% names(res$blue_table)) {
res$blue_table %>% dplyr::select(all_of(entry_col_name), !!sym(trait) := BLUE_Combined)
} else { NULL }
}) %>% purrr::discard(is.null)
if (length(trait_df_list) < 2) { showModal(modalDialog(title = "Insufficient Data", "PCA requires at least two traits with valid Combined BLUEs.", easyClose = TRUE)); return() }
df_pca <- trait_df_list %>% purrr::reduce(full_join, by = entry_col_name)
df_pca_numeric <- df_pca[, -1, drop = FALSE]
rownames(df_pca_numeric) <- df_pca[[1]]
tryCatch({
res.pca <- FactoMineR::PCA(df_pca_numeric, graph = FALSE, ncp = 5)
pca_results(list(pca = res.pca))
output$pca_plot_biplot <- renderPlot({ fviz_pca_ind(res.pca, col.ind = "cos2", gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), repel = TRUE) })
output$pca_plot_scree <- renderPlot({ fviz_screeplot(res.pca, addlabels = TRUE) })
output$pca_plot_varcontrib <- renderPlot({ fviz_pca_var(res.pca, col.var = "contrib", gradient.cols = c("white", "blue", "red")) })
output$pca_table_summary <- renderTable({ round(factoextra::get_eigenvalue(res.pca), 2) }, rownames = TRUE)
output$pca_status <- renderUI({ span(style = "color: green; font-weight: bold;", icon("check"), " PCA Completed (OK)") })
updateTabsetPanel(session, "analysis2_tabs", selected = " PCA Plot")
}, error = function(e) { showModal(modalDialog(title = "PCA Error", paste("Error in PCA analysis:", e$message), easyClose = TRUE)) })
})
# --- Block E14: Analysis 2 - Correlation ---
observeEvent(input$run_corr, {
req(pca_results())
df_corr <- tryCatch({ pca_results()$pca$call$X }, error = function(e) NULL)
if (is.null(df_corr)) {
showModal(modalDialog(title = "Correlation Error", "PCA results missing. Please run PCA first.", easyClose = TRUE))
return()
}
tryCatch({
# Calculate correlation matrix and p-values
corr_obj <- corrplot::cor.mtest(df_corr, conf.level = 0.95)
corr_matrix <- cor(df_corr, use = "complete.obs")
p_value_matrix <- corr_obj$p
# Generate and store the interpretation
interpretation_text <- generate_correlation_interpretation(corr_matrix, p_value_matrix)
corr_interpretation(interpretation_text)
# --- SIMPLIFIED AND CORRECTED PLOT RENDERING ---
# Plot 1: A single, clear correlation matrix
output$corr_plot1 <- renderPlot({
corrplot(
corr_matrix,
method = "number",        # Use color to represent correlation strength
addCoef.col = "black",   # Overlay coefficients in solid black text
type = "upper",
order = "hclust",
p.mat = p_value_matrix,  # Use p-values to blank non-significant results
sig.level = 0.05,
insig = "pch",
tl.col = "black",        # Text label color
tl.srt = 45,             # Rotate text labels for readability
number.cex = 0.9         # Adjust number size
)
})
# Plot 2 has been removed from the logic.
output$corr_status <- renderUI({
span(style = "color: green; font-weight: bold;", icon("check"), " Correlation Completed (OK)")
})
updateTabsetPanel(session, "analysis2_tabs", selected = " Correlation Plot")
}, error = function(e) {
showModal(modalDialog(title = "Correlation Error", paste("Error in correlation plotting:", e$message), easyClose = TRUE))
})
})
output$corr_interpretation_ui <- renderUI({
req(corr_interpretation())
div(style = "background-color: #f8f9fa; border-left: 5px solid #007bff; padding: 15px; border-radius: 5px;",
corr_interpretation()
)
})
#==================================================================
# -------- Section 2.5: Download Handlers --------
#==================================================================
# -------- Block D1: Download Handler - CRD Results (Corrected for reactiveValues) --------
output$download_crd_zip <- downloadHandler(
filename = function() paste0("CRD_Results_", Sys.Date(), ".zip"),
content = function(file) {
# 1. Create a temporary directory.
tmp_dir <- tempfile("crd_zip_")
dir.create(tmp_dir)
on.exit(unlink(tmp_dir, recursive = TRUE), add = TRUE)
files_to_zip <- c()
# Access the reactiveValues object directly
res <- crd_results
sanitize <- function(x) gsub("[^A-Za-z0-9_]", "_", x)
# 2. Iterate through the traits selected in the UI.
for (trait in req(input$crd_traits)) {
trait_id <- make.names(trait)
tname <- sanitize(trait)
# 3. Check for and save each result type using its unique key.
# --- Save Summary CSV ---
summary_key <- paste0("summary_", trait_id)
if (!is.null(res[[summary_key]])) {
fname <- file.path(tmp_dir, paste0(tname, "_summary.csv"))
write.csv(res[[summary_key]], fname, row.names = FALSE)
files_to_zip <- c(files_to_zip, fname)
}
# --- Save ANOVA CSV ---
anova_key <- paste0("anova_table_", trait_id)
if (!is.null(res[[anova_key]])) {
fname <- file.path(tmp_dir, paste0(tname, "_anova.csv"))
write.csv(res[[anova_key]], fname, row.names = FALSE)
files_to_zip <- c(files_to_zip, fname)
}
# --- Save DMRT Text File ---
dmrt_key <- paste0("dmrt_text_", trait_id)
if (!is.null(res[[dmrt_key]]) && nzchar(res[[dmrt_key]])) {
fname <- file.path(tmp_dir, paste0(tname, "_dmrt_results.txt"))
writeLines(res[[dmrt_key]], fname)
files_to_zip <- c(files_to_zip, fname)
}
# --- Save Missing Combinations CSV ---
missing_key <- paste0("missing_combinations_", trait_id)
if (!is.null(res[[missing_key]]) && nrow(res[[missing_key]]) > 0) {
fname <- file.path(tmp_dir, paste0(tname, "_missing_combinations.csv"))
write.csv(res[[missing_key]], fname, row.names = FALSE)
files_to_zip <- c(files_to_zip, fname)
}
# --- Save Interaction Plots PDF ---
plots_key <- paste0("plots_", trait_id)
plot_list <- res[[plots_key]]
if (!is.null(plot_list) && length(plot_list) > 0) {
for (pname in names(plot_list)) {
fname <- file.path(tmp_dir, paste0(tname, "_", sanitize(pname), "_interaction.pdf"))
pdf(fname, width = 8, height = 5)
print(plot_list[[pname]])
dev.off()
files_to_zip <- c(files_to_zip, fname)
}
}
}
# 4. Zip all the created files.
zip::zip(zipfile = file, files = files_to_zip, mode = "cherry-pick")
},
contentType = "application/zip"
)
# -------- Block D2: Download Handler - Analysis 1 ZIP (Corrected) --------
output$download_analysis1 <- downloadHandler(
filename = function() {
design_name <- tools::toTitleCase(active_design() %||% "Analysis")
paste0("PbAT_", design_name, "_Results_", Sys.Date(), ".zip")
},
content = function(file) {
tmp_dir <- tempfile("analysis1_zip_")
dir.create(tmp_dir)
on.exit(unlink(tmp_dir, recursive = TRUE), add = TRUE)
files_to_zip <- c()
descriptive_list <- descriptive_results()
model_list <- model_results()
for (trait in names(model_list)) {
tryCatch({
# --- Save Descriptive Results ---
if (!is.null(descriptive_list[[trait]])) {
desc_res <- descriptive_list[[trait]]
fname_sum <- file.path(tmp_dir, paste0(trait, "_descriptive_summary.csv"))
write.csv(desc_res$summary, fname_sum, row.names = FALSE)
fname_box <- file.path(tmp_dir, paste0(trait, "_boxplot.pdf"))
pdf(fname_box, width = 11, height = 8.5); print(desc_res$boxplot); dev.off()
if (!is.null(desc_res$qq) && length(desc_res$qq) > 0) {
fname_qq <- file.path(tmp_dir, paste0(trait, "_qqplots.pdf"))
pdf(fname_qq, width = 11, height = 8.5)
for (p in desc_res$qq) { print(p) }
dev.off()
files_to_zip <- c(files_to_zip, fname_qq)
}
files_to_zip <- c(files_to_zip, fname_sum, fname_box)
}
# --- Save Model Results ---
trait_model_res <- model_list[[trait]]
if (!is.null(trait_model_res$Fixed)) {
fixed_res <- trait_model_res$Fixed
if (is.data.frame(fixed_res$anova_table)) { fname <- file.path(tmp_dir, paste0(trait, "_Fixed_ANOVA.csv")); write.csv(fixed_res$anova_table, fname, row.names=F); files_to_zip <- c(files_to_zip, fname) }
if (is.data.frame(fixed_res$blue_table)) { fname <- file.path(tmp_dir, paste0(trait, "_Fixed_BLUEs.csv")); write.csv(fixed_res$blue_table, fname, row.names=F); files_to_zip <- c(files_to_zip, fname) }
if (is.data.frame(fixed_res$lrt_table)) { fname <- file.path(tmp_dir, paste0(trait, "_Fixed_LRT.csv")); write.csv(fixed_res$lrt_table, fname, row.names=F); files_to_zip <- c(files_to_zip, fname) }
if (is.data.frame(fixed_res$var_comps)) { fname <- file.path(tmp_dir, paste0(trait, "_Fixed_VarComps.csv")); write.csv(fixed_res$var_comps, fname, row.names=F); files_to_zip <- c(files_to_zip, fname) }
}
if (!is.null(trait_model_res$Random)) {
rand_res <- trait_model_res$Random
if (is.data.frame(rand_res$blup_table)) { fname <- file.path(tmp_dir, paste0(trait, "_Random_BLUPs.csv")); write.csv(rand_res$blup_table, fname, row.names=F); files_to_zip <- c(files_to_zip, fname) }
if (is.data.frame(rand_res$lrt_table)) { fname <- file.path(tmp_dir, paste0(trait, "_Random_LRT.csv")); write.csv(rand_res$lrt_table, fname, row.names=F); files_to_zip <- c(files_to_zip, fname) }
if (is.data.frame(rand_res$var_comps)) { fname <- file.path(tmp_dir, paste0(trait, "_Random_VarComps.csv")); write.csv(rand_res$var_comps, fname, row.names=F); files_to_zip <- c(files_to_zip, fname) }
}
}, error = function(e) { showNotification(paste("Error for trait", trait, ":", e$message), type = "warning") })
}
# CORRECTED FUNCTION CALL
zip::zipr(zipfile = file, files = files_to_zip, recurse = FALSE)
},
contentType = "application/zip"
)
# -------- Block D3: Download Handler - Analysis 2 ZIP (FINAL CORRECTED) --------
output$download_analysis2 <- downloadHandler(
filename = function() paste0("PbAT_Analysis2_Results_", Sys.Date(), ".zip"),
content = function(file) {
# 1. Create a temporary directory.
tmp_dir <- tempfile("analysis2_zip_")
dir.create(tmp_dir)
on.exit(unlink(tmp_dir, recursive = TRUE), add = TRUE)
files_to_zip <- c()
tryCatch({
# --- GGE Plots ---
if (!is.null(gge_results())) {
for (i in 1:4) {
fname <- file.path(tmp_dir, paste0("GGE_Plot_Type", i, ".pdf"))
pdf(fname, width = 7, height = 6); print(plot(gge_results(), type = i)); dev.off()
files_to_zip <- c(files_to_zip, fname)
}
}
# --- PCA Plots & Data ---
if (!is.null(pca_results()$pca)) {
pca_obj <- pca_results()$pca
pdf(file.path(tmp_dir, "PCA_Biplot.pdf")); print(fviz_pca_ind(pca_obj, repel = TRUE)); dev.off()
pdf(file.path(tmp_dir, "PCA_Scree.pdf")); print(fviz_screeplot(pca_obj, addlabels = TRUE)); dev.off()
pdf(file.path(tmp_dir, "PCA_Contributions.pdf")); print(fviz_pca_var(pca_obj)); dev.off()
write.csv(pca_obj$ind$coord, file.path(tmp_dir, "PCA_Coordinates.csv"))
write.csv(factoextra::get_eigenvalue(pca_obj), file.path(tmp_dir, "PCA_Eigenvalues.csv"))
files_to_zip <- c(files_to_zip, file.path(tmp_dir, "PCA_Biplot.pdf"),
file.path(tmp_dir, "PCA_Scree.pdf"), file.path(tmp_dir, "PCA_Contributions.pdf"),
file.path(tmp_dir, "PCA_Coordinates.csv"), file.path(tmp_dir, "PCA_Eigenvalues.csv"))
}
# --- Correlation Plot & Data ---
if (!is.null(pca_results()$pca$call$X)) {
corr_data <- pca_results()$pca$call$X
pdf(file.path(tmp_dir, "Correlation_MatrixPlot.pdf"), width=8, height=8)
corrplot::corrplot(cor(corr_data, use="complete.obs"), method="number", type="upper")
dev.off()
pdf(file.path(tmp_dir, "Correlation_Pairs.pdf"))
PerformanceAnalytics::chart.Correlation(corr_data, histogram = FALSE)
dev.off()
write.csv(cor(corr_data, use="complete.obs"), file.path(tmp_dir, "Correlation_Matrix.csv"))
files_to_zip <- c(files_to_zip, file.path(tmp_dir, "Correlation_MatrixPlot.pdf"),
file.path(tmp_dir, "Correlation_Pairs.pdf"), file.path(tmp_dir, "Correlation_Matrix.csv"))
}
}, error = function(e) {
showNotification(paste("Error saving Analysis 2 results:", e$message), type = "error")
})
# 2. Zip the files using their full paths.
zip::zip(zipfile = file, files = files_to_zip, mode = "cherry-pick")
},
contentType = "application/zip"
)
}
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
devtools::load_all()
run_app()
devtools::load_all()
devtools::document()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
setwd("E:/PBAT")
devtools::load_all()
run_app()
devtools::document()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
devtools::load_all()
run_app()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
run_app()
devtools::load_all()
devtools::load_all()
run_app()
